### 基本概念

以下是一些重要的名词、概念，为了更好的理解本文，请务必先对这些名词、概念的含义有一些了解。

<a name="basic-unit"></a>
- 基本单位：画布上，所有组件的位置和尺寸，都是8px的整数倍，我们将8px称为一个**基本单位**
    - 这是与Ux团队协商的结果,以8px作为基本单位，可以让你布局的过程更简单快速，布局的结果也更加规整;
    - 基本单位有两个相关性较大的概念：[尺寸](#size-relativity)和[响应性](#responsiveness)
- 通常来说，一个APP里所有组件的状态分为设计态和运行态两个状态
    - 设计态指的是我们在开发app的过程中，app所处的状态，**Awade的画布上的所有组件，始终处于设计态**；
    - 运行态指的是app开发完毕，实际运行时的状态。特别注意的是，我们在预览app时，它也是处于运行态；
- 响应性：指组件在某个方向上可以跟随浏览器的尺寸变化而变化的特点
    - 这里的方向有两个：水平方向和垂直方向，分别代表着屏幕的x轴和y轴；
    - **组件在设计态时，其响应性将被忽略**，这样做一方面是为了开发app过程简单，另一方面是为了awade自身的实现简单；
    - 适当的响应性可以让你的app充分利用屏幕上的空间，从而提升app的易用性；
- 组件的分类
    - 容器类组件
    - 普通组件

### 布局模式

任何web应用的布局模式，归纳起来只有两种模式：

- 单屏模式
    - 整个app在垂直方向上只恰好占满一屏幕的高度，app内部通过各种容器将多余的视图收纳起来，在必要的时候才展示出来；
    - 一般来说，一些模拟桌面应用的app会倾向于使用这个模式来布局界面；
    - 我们也推荐尽量采用整个方式来布局界面；
- 多屏模式
    - 整个app会按照需要在垂直方向上占据任意的高度，这类app往往有很深的垂直滚动条；
    - 传统的web页面一般采用整个布局方式；
    - 我们认为应该尽量避免采用整个布局方式；

你实现一个app的时候，**第一步就必须要挑选好一个模式，并且一旦模式挑选好了后，就不要轻易改变**，因为改变模式的代价是高昂的，这个现象不仅在使用awade开发页面时是这样，在手工编码开发页面时，改变模式的代价比使用awade开发甚至要更高昂。因为调整模式会导致整个页面的结构和所有css要重写，这是一个非常麻烦的事情。

最后，在awade中，采用多屏模式开发时，所有组件在垂直方向上的响应性将无法按照预期工作，这点必须由开发者自行处理。我们的建议是：**在多屏模式下，关掉所有组件在垂直方向上的响应性**。这个问题将在awade支持组件的`min-height`功能后得到一定程度的缓解。

### 基础操作

如下是画布上的一些基础操作：

<a name="add-comp"></a>
#### 新增组件

在左侧组件面板中找到想添加的一个组件，将其拖入画布即可，如下图

拖进来的组件丢到哪个网格上，则此组件将成为该网格的成员。下图演示的是画布上存在上下级网格时，拽进来的组件丢在不同的网格上的不同效果


> 提示：组件丢到画布上之后，想要知道它属于哪个网格，最简便的识别方式是查看结构树。

<a name="select"></a>
#### 选中组件

在画布上操作组件和大多数软件相似，需要先选中一个组件。有两个方法可以选中画布上的一个组件：

1. 在结构树上选中组件，当待选中组件处于某个容器里的时候，通过结构树来选择组件是最方便的；
2. 在画布上通过鼠标点选选择组件，这是最快捷的方式了

选择组件的过程如下图所示，注意到鼠标点选时，需要点击到目标组件外部蓝色的框框才可以选中它。

#### 选中标示框

鼠标hover到组件上，或者选中一个组件的时候，画布会给目标组件套上一个蓝色或者黄色的框框，这个框框称为选中标示框。**标示框的主要作用是**
- 标识当前组件的尺寸和位置，注意这个标示框是套在组件的外头的，**它的内径长宽才是组件的实际尺寸**；
- 提供修改尺寸和位置的交互入口；
- 提供组件特有的其他操作交互入口；

关于标示框的颜色：
- 标示框为蓝色时，表示标示框当前套住的组件位置、尺寸是精确的；
- 标示框为黄色时，表示标示框框住的目标组件在画布上不可见（比如它在一个未激活的tab页下），此时，标示框的位置和尺寸是不精确的，因此，在黄色框状态下，标示框无法提供任何操作；

标示框上会列出当前组件的所有可用操作按钮，当组件的尺寸很小而容纳不下操作按钮时，这些操作按钮会被隐藏。此时，只能在画布右侧的操作面板中才能找到他们。

#### 删除组件

先在画布上[选中](#select)待删除的组件，然后通过点击组件操作按钮栏里的删除组件按钮来删除它，如下图所示


注意，组件按钮栏会呈现在两个不同的位置，一个是在组件的选中标示框上，一个是右侧操作面板中。

> 提示，删除一个组件时，awade不会给出二次确认，如果你点错了，那请及时通过“撤销”功能撤销误操作。

#### 改变组件位置

先在画布上[选中](#select)待改变位置的组件，然后拖拽标示框的标题栏部分，可以改变组件的位置。拖拽的过程中，标示框内部的灰色透明区域代表着目标组件当前的尺寸和位置，**你可以透过透明区域获知其与画布上其他组件的相对位置以减少试错次数**。

> 注意到，拖动过程中，组件的位置是以[*基本单位*](#basic-unit)跳跃的，而不是平滑移动的，这使得一个组件很容易与其他组件保持位置上的对齐。

#### 改变组件的尺寸

依然要先[选中](#select)目标组件，然后拖动选中标示框的4条边来改变组件的尺寸，如下图


注意到，改变尺寸的过程中，awade给出了一个以px为单位的尺寸，如图


这个尺寸不一定是组件在运行态下的尺寸，仅仅只能用它与画布上其他组件的尺寸和位置做参考。

#### 延展网格尺寸

画布上的网格理论上是无限大的，它的右侧和下方可以被无限延展以容纳更多的组件。注意到每个网格的右下角，有3个按钮，如下图


这3个按钮用于延展网格的尺寸，点击一下网格就会在相应的方向上增加5个[*基本单位*](#basic-unit)长度，如下图


注意：延展的网格尺寸是临时的，这个延展得到的尺寸不会在运行时产生任何的影响，awade也不会被持久化这个尺寸。所以，不存在所谓的缩减网格尺寸的做法，网格在重新绘制之后，总是会自动将网格尺寸重置为尽可能小的值。

<a name="responsiveness"></a>
### 组件的响应性

在基本概念中，我们简要的介绍了响应性以及它的作用，这里详细介绍如何干预组件的响应性。

选中任意组件，在右侧样式面板中可以响应性设置栏，通过点亮和点灭开关即可干预组件的响应性。特别需要注意的是，如前文提到的，组件的响应性只在运行时才能体现出来，而组件在画布上永远处于设计态，所以，你在画布上是看不出响应性的效果的。最快速方便的测试响应性效果的方法是预览，如下图

> 注意到
> 
> 1. 我们为每个组件设计了最合适的响应性默认值。
> 2. 绝大多数组件的响应性都是关闭的。

最后，并不是所有组件都支持响应性的，例如按钮组件，它在垂直方向上就不支持响应性，因此，你打开了按钮在垂直方向上的响应性，只会影响其在垂直方向上所占的位置，而不会实际改变按钮的高度。


### 画布上的尺寸

<a name="size-priority"></a>
#### 尺寸优先级

画布上各式组件的尺寸优先级是不同的，awade的原则是：**绝对布局组件的尺寸优先级低于响应布局组件的尺寸优先级**，这个原则同时适用于水平和垂直方向。

基于这个原则，当浏览器的尺寸变小的时候，awade总是会让浏览器先“欺负”响应布局组件，将其压扁，而对绝对布局组件的尺寸置之不理。反过来，浏览器的尺寸变大时也类似，多出来的尺寸awade会优先分配给响应布局组件，而依然对绝对布局组件的尺寸置之不理。

<a name="size-relativity"></a>
#### 相对尺寸

画布上尺寸实际上都是相对尺寸，而非绝对尺寸。在画布上，我们使用[*基本单位*](#basic-unit)替代实际尺寸（以px为单位），从而让布局过程的尺寸、位置都在同一个参照系下完成。[*基本单位*](#basic-unit)是一个相对单位，而不是绝对单位。也就是说，我在设计时拖出来的组件的尺寸数量，都是[*基本单位*](#basic-unit)数，这些数值体现的是组件间的尺寸的相对大小，而非绝对大小。

> 提示：这是理论，听不懂也没关系

下面说说相对尺寸与实际尺寸的换算关系，这个比较重要。

没有响应性的组件的的尺寸换算关系超级简单：实际尺寸(px)=[*基本单位*](#basic-unit)数 * 8px。

具有响应性的组件的的尺寸换算关系则复杂许多，**这是因为我们需要有浏览器的尺寸参与运算才能完成响应性组件的尺寸的最终确认，而浏览器的尺寸是一个运行时值，在设计时无法拿到**。

下面以实例说明换算原理

> 详细的换算算法非常复杂，庆幸的是awade会自动生成相关代码，作为开发者，你无需关心这些

**先从最简单的场景开始**

拖一个`jigsaw-input`组件到画布上，左侧靠着画布左侧边缘，**长度任意**，并打开它的水平响应性，如下图

我们无需预览即可轻易预见到这个组件将撑满一整行的所有空间。注意此时组件的长度是任意的，哪怕就只给它分配一个[*基本单位*](#basic-unit)，运行时，它也将沾满一整行。

**稍微复杂一些的场景：再来一个组件**

再拖一个新的`jigsaw-input`组件到画布上，依然点亮它在水平方向上的响应性。在这个场景下，我们就要非常关注宽度了。让第二个组件的尺寸恰好是第一个组件的一半，如下图

> 图中，第一个组件的宽度是320px，第二个组件的宽度是160px
>
> 你可以试一下其他数值 ，例如480px和240px，你会发现效果是完全一致的


好，预览一下效果


我们看到，这2个组件无论浏览器的尺寸如何变化，始终保持着 320:160 的关系，320:160 也等于 2:1。说到这里，大家应该对响应组件的尺寸分配原理有一个粗略的理解了对吧。此时我再说：设计时画布上的所有尺寸数值，都是比例（相对）关系，应该就不难理解了，对吧。

**再给一个更复杂的场景：混搭场景**

莫慌，这个场景已经是你使用awade的画布布局页面时的最复杂的场景了。

在前面场景的基础上，再拖一个按钮到画布上，丢到最右侧。注意保持按钮在水平方向上的响应性为关闭状态。此时，我们在一行上，就拥有了响应性组件和非响应性组件混搭的场景了，如下图


再预览一下效果


我们看到，浏览器优先将尺寸分配给了按钮（非响应性组件），然后才把剩余的尺寸按2:1的比例关系分配给剩余的两个响应性组件。其实也很好理解对吧。在垂直方向上，尺寸的分配过程和水平上基本类似。

> 手写代码时，垂直方向上的响应性是所有初级前端程序员的噩梦，所用的技巧加起来都可以写成一本书了
>
> 但在awade中，垂直方向和水平方向上的响应性却是一样简单，在这里都不值得一提。

### 组件重叠

画布允许组件相互重叠，组件恰当的重叠可以布局出更加复杂和随意的ui以满足尽可能多的场景。

但是，重叠也带来了一些额外的复杂性需要开发者注意的。

#### 重叠的定义

当画布上两个组件的标示框（篮框）的内径覆盖了相同的网格时，此时，这2个组件就相互叠加了，注意，**是蓝框区域重叠就算叠加了，而不仅是在组件的可视部分重叠才算叠加**。

<a name="responsiveness-failure"></a>
#### 响应性失效

这是组件重叠的代价，**重叠在一起的所有组件，都将失去响应性**，这是为了降低awade布局算法的复杂性而做的妥协。请别泄气，通过本文后半部分介绍的高级技巧，我们是有办法让组件重叠的同时，也获得一定程度上的响应性的。

#### 组件的层级

层级关系是组件重叠带来的另一个复杂性。

实际上，即使组件不重叠，它们也是有层级的。画布的层级原则是：先添加进来的组件的层级低于后加进来的组件的层级，从效果上看，就是先添加进去的组件将被后添加进去的组件盖住。这个原则符合一般的认知常识。你往地上丢一些纸片，显然先丢下去的纸片是会被后丢下去的纸片给盖住的对不对。

层级的高低在组件不相互叠加的时候，没有任何影响，但是当组件产生叠加时，层级对布局效果的影响则是决定性的。

那么，**如何得知组件的等级是多少呢？**结构树上，同级组件自上而下的顺序，即为当前网格下的组件层级从低到高的顺序。有个特殊情况：当组件被选中的时候，它的层级会被临时提升到最高，而当一个组件被取消选中时，它的层级将恢复到它原有的层次。

**如何改变层级呢？**有两个手段：

- 通过提升或者降低层级按钮来提升或降低层级，如下图

- 在结构树上选中并拖拽组件到合适的层级位置上，如下图

#### 重叠连锁

重叠连锁是一个有趣的现象，并不是重叠带来的新问题。

当两个组件相互重叠时，它们所在的区域会融合在一起，变成一个刚刚好能够容纳得下它们的更大的矩形，如下图


这个更大的矩形如果覆盖到了其他组件，则此过程会继续，这将产生一个更大的矩形来容纳这些组件，直到融合后的矩形没有能够覆盖到其他组件为止。此时，**这所有的被融合在一起的组件将全部失去响应性**。这就是重叠的连锁反应现象。

一般来说，一个比较规则的界面布局，重叠连锁不会产生太大的影响，此时重叠连锁将是很容易预期到结果的。相反的，如果你出于试用awade布局器的目的而多个组件胡乱摆放，则很容易触发这个连锁反应而让组件失去响应性，这点需要注意。

### 画布上的空白

画布上的空白实际上也是一种占位符，协助你完成复杂的布局。这些空白对布局的美观甚至是易用性起到重要的作用，但是常常被无视。

> awade本来就是要让这些空白被无视，所以你平时注意不到它们是正常的

但并不是所有的空白都能对布局产生影响，下图中蓝色区域中的空白不会对布局产生影响，可以100%被无视。

### 容器

容器具有普通组件的一切特性，此外它拥有普通组件所没有的重要能力：能够装得下其他组件或者其他容器。容器的这个特殊能力导致容器组件比普通组件要复杂一些，因此我们需要专门描述这类组件，以帮助你更好的驾驭他们。

#### 结构树与容器

也许你以及注意到了，每个容器会在结构树上产生一个新的节点，而这个容器内的所有组件会被挂到这个容器节点下。当容器里还有容器时，结构树的层级深度就会进一步增加。结构树是处理好不同层级容器的一个绝佳工具。

#### 组件搬家

在[新增组件](#add-comp)小节，我们已经简单介绍了新增组件时如何将组件添加到不同的容器中去了。

> 新增组件时，松开鼠标的一刹那，鼠标所在位置上如果有多个可用容器，则新增的组件将会被添加到结构树上最深的那个容器上。

那么还有一个问题：我们如何将画布上一个已有的组件“搬”到其他容器里去呢？通过在画布上拖动组件到新的容器里去的方法是无法达成这个目的的，因为这个操作有歧义：awade搞不清楚你是想让这个组件叠加到容器的上面，还是想把组件搬家到容器里。正确的方法是在结构树上拖拽，如下图：


> 通过操作结构树，你可以在一次操作里实现将组件搬到任意其他容器里去。

### 布局技巧

<a name="align-right"> </a>
#### 靠右、靠下排列

我们都知道浏览器在布局UI上的元素的时候，总是按照从左到右，从上到下的顺序进行的，所以在布局时，靠左、靠上排列是非常简单的事情，你只要在画布上把组件拖在那就行了，不需要有额外的事情要做。

但是，如果反过来 ，你希望将一个组件靠右或者靠下摆放，则还需要额外做一些事情才能够达到效果。这在手写代码实现web页面的时候，也常常是一个令人头疼的问题，那么在awade，我们是如何解决这类问题的呢？

在开始之前，先给要介绍一个神奇的组件：占位符，它在这里：



正如它的名字一样，它的主要功能是在一些复杂的布局场景中提供辅助，从而让我们快速的完成布局目标。下面，我们介绍一下如何使用它来在一行上实现靠右排列组件。

首先，拖一个占位符到画布上，调整它的宽度到一个合适的值，然后，**最重要的是，将其水平方向上的响应性点亮**，如下图



然后，拖拽其他你需要的任意组件到它的右侧。然后预览一下，看看是不是无论浏览器的尺寸如何改变，你的组件依然乖乖的停靠在浏览器的右侧了。是不是很简单？


> 占位符的原理超级简单，我们利用它的响应性将目标组件“挤”到右边去而已。
>
> 这背后深一点的原理是[尺寸优先级](#size-priority)，绝对布局组件的尺寸优先级高于响应性布局组件的尺寸优先级，所以在浏览器尺寸变化的时候，浏览器会优先欺负占位符，将其压扁。

将一个组件靠下摆放的技巧和靠右摆放的技巧是相似的，差别在于要将占位符的垂直响应性打开。

#### 居中排列

在开始阅读本小结之前，请确保你已经阅读了[靠右、靠下排列](#align-right)小节，我们需要使用到相似的技巧。一般有水平居中，垂直居中两个方式，在awade中使用到的技巧是相似的，这里以水平居中为例说明如何实现。

我们依然需要借助水平响应的占位符组件来实现居中排列，这次，我们需要用到2个占位符，一个位于左侧，一个位于右侧，而将目标组件放在中间。并且将左右两侧的占位符的宽度调整为一样大（1:1），如下图


在预览时，我们可以看到，中间的目标组件无论浏览器的尺寸如何变化，始终位于屏幕的正中间，目标达成！


> 如果你想知道其中的原理，请阅读[相对尺寸](#size-relativity)小节，你将了解到为何要左右占位符的宽度设置为 1:1。

#### 组件重叠+靠右

这是一个实际案例。

我们的目标是要布局一个header栏，这个header具有蓝色背景，并且所有的组件都在header中靠右排列，效果如下


首先，awade布局器的背景默认是白色，但是这个需求中，我们需要一个蓝色的背景。显然这样的效果只能通过组件叠加才能实现。如果不考虑靠右排列的效果，则很简单，只要按照下面的步骤操作即可：

1. 拖一个div组件到画布上 ，并拖动边框使其大小合适；
2. 给这个div添加一个蓝色背景；
3. 将其他组件一一拖到蓝色div的上面，调整好位置和尺寸；

此时，看起来是这样的：


很显然，我们轻而易举的实现了除了组件靠右排列以外的所有目标，下面着重说明一下如何让组件靠右。实际上，这里所需的技巧我们在[靠右、靠下排列](#align-right)小节里已经详细介绍过了。

> 如果你还没阅读[靠右、靠下排列](#align-right)小节，那现在跳过去仔细读一读是有好处的

接下来，我们要拖一个占位符到蓝色区域的左侧，并将水平上的响应性打开，这样，这个占位符就会将蓝色区域“挤到”右边去，从而实现我们的最后一个目标。此时，打开预览界面，我们发现和我们预期的效果一致，蓝色区域的确已经可以靠右排列了。但是有个问题，左侧部分是白色的，这不符合要求。

这个问题解决起来超级简单，只要把左侧占位符的背景也改成蓝色即可。最终效果如下：


下面我们来扩展一下这个案例，我们将充分挖掘占位符的神奇功能。

假设我们的需求变成下图这样，两端和中间都有一些组件，并且整体header具备水平响应性：



咋一看很坑爹，但是我们使用前文介绍的技巧就可以搞定，下面我一步步来：

1、和前文一样，组件需要有背景，那就用div来作底，先把左侧部分搞定，此时看起来是这样的


2、接下来采用相似的方法，处理好中间和右侧的部分。注意，左中右3部分组件的中间要先空出相同宽度的空白来。此时看起来是这样的：


3、神奇的一步是，我们拖进去两个占位符，并将其水平响应性打开，并且要保持这2个占位符的尺寸之比是 1:1，这是中间部分能够100%居中的秘密。

最后一步是将中间的2个占位符的背景也改为蓝色就结束了，但是我为了更好的说明原理，我在这个动作前我抓了个图，如下


万一你偷懒没有跟我一步步操作，那希望这个gif图可以帮助你更好的了解这2个占位符起作用的原理。

如果继续扩展：

- 如果要求header有更多的区段，那就要用更多的占位符来撑开这些区段了；
- 如果要求中间部分不是100%居中，而是位于靠右侧1/3处，那就将2个占位符的尺寸调整为为 2:1 即可；